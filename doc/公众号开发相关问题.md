# 公众号开发相关问题

- 变量命名问题（小驼峰，大驼峰，下划线，保持一致）
- `antd-mobile@2.x` 不在依赖 `moment`,可以减少 `50+KB` 的体积，但是需要自行实现 `时间格式化` 功能
- openId 获取

```js
const getOpenId = () => {
  window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${APPID}&redirect_uri=${encodeURIComponent(
    window.location.href
  )}&response_type=code&scope=snsapi_base&#wechat_redirect`;
};
if (!openId) getOpenId();
```

- 路由拦截器

使用 `React-Router` 做为前端路由，在 `Route` 外封装一层达到拦截的目的，更加一定的条件决定跳转页面时，跳转到目标页面还是登陆页面

```js
...

const WhiteList = [RouterList.navigation, RouterList.todo];

const PrivateRoute = ({ component: Component, ...rest }) => (
  <Route
    {...rest}
    render={props => {
      const isAuthorized =
        WhiteList.includes(rest.path) ||
        Util.storage.get(CONSTANT.LOGIN.STATUS) === CONSTANT.LOGIN.IS_LOGGED;
      return isAuthorized ? (
        <Component {...props} />
      ) : (
        <Redirect
          to={{
            pathname: RouterList.navigation,
            state: { from: props.location }
          }}
        />
      );
    }}
  />
);
```

- 手势（长按，旋转），代码如下

```js
import React from "react";

let LONG_PRESS_TIME = 500, // 判定触发长按事件的时间，毫秒单位
  MOVE_DISTANCE = 10, // 判定触发移动时间的距离
  ROTATE_SWITCH = false;

const TOUCH_STATUS = {
  TAP: "tapping", // 单击
  LONG_TAP: "pressing", // 长按
  MOVING: "moving", // 移动
  ROTATE: "rotate" // 旋转
};

let touchStatus = TOUCH_STATUS.TAP,
  timeStart = 0,
  _center = { x: 0, y: 0 },
  _angle = 0,
  _location = { x: 0, y: 0 },
  _lastLocation = { x: 0, y: 0 };

const getMatrix = (a, b, c, d, e, f) => {
  var aa = Math.round((180 * Math.asin(a)) / Math.PI);
  var bb = Math.round((180 * Math.acos(b)) / Math.PI);
  var cc = Math.round((180 * Math.asin(c)) / Math.PI);
  var dd = Math.round((180 * Math.acos(d)) / Math.PI);
  var deg = 0;
  if (aa === bb || -aa === bb) {
    deg = dd;
  } else if (-aa + bb === 180) {
    deg = 180 + cc;
  } else if (aa + bb === 180) {
    deg = 360 - cc || 360 - dd;
  }
  return deg >= 360 ? 0 : deg;
};

export default props => {
  const handleTouchStart = ev => {
    let target = ev.target;
    if (target.classList.contains("rotate")) {
      ROTATE_SWITCH = true;
      target = target.parentNode.querySelector("img");
    } else {
      ROTATE_SWITCH = false;
    }
    timeStart = Date.now();
    const touche = ev.touches[0];
    const elRect = target.getBoundingClientRect();
    _center = {
      x: elRect.left + elRect.width / 2,
      y: elRect.top + elRect.height / 2
    };
    _location = { x: touche.clientX, y: touche.clientY };
    _lastLocation = _location;
    _angle =
      Math.atan2(_location.y - _center.y, _location.x - _center.x) /
      (Math.PI / 180);
  };

  const handleTouchEnd = ev => {
    if (ROTATE_SWITCH === true) {
      touchStatus = TOUCH_STATUS.ROTATE;
    } else if (
      Math.abs(_lastLocation.x - _location.x) > MOVE_DISTANCE ||
      Math.abs(_lastLocation.y - _location.y) > MOVE_DISTANCE
    )
      touchStatus = TOUCH_STATUS.MOVING;
    else if (
      Date.now() - timeStart > LONG_PRESS_TIME &&
      touchStatus !== TOUCH_STATUS.ROTATE
    )
      touchStatus = TOUCH_STATUS.LONG_TAP;
    else touchStatus = TOUCH_STATUS.TAP;

    switch (touchStatus) {
      case TOUCH_STATUS.LONG_TAP:
        longTap(ev);
        break;
      case TOUCH_STATUS.MOVING:
        moving(ev);
        break;
      case TOUCH_STATUS.ROTATE:
        rotate(ev);
        break;
      default:
        tap(ev);
    }
  };

  const tap = ev => {
    console.log(TOUCH_STATUS.TAP);
  };

  const longTap = ev => {
    console.log(TOUCH_STATUS.LONG_TAP);
    props.onLongTap && props.onLongTap(ev);
  };

  const moving = (ev, pos) => {
    console.log(TOUCH_STATUS.MOVING);
    const target = ev.target,
      nodeName = target.nodeName.toUpperCase();
    if (
      nodeName === "IMG" &&
      target.parentNode.parentNode.parentNode.classList.contains("active")
    ) {
      let lastTop = target.dataset["top"] || 0,
        lastLeft = target.dataset["left"] || 0;
      if (!pos) {
        const top = getComputedStyle(target).getPropertyValue("top"),
          left = getComputedStyle(target).getPropertyValue("left");
        target.dataset["top"] = parseFloat(top);
        target.dataset["left"] = parseFloat(left);
      } else {
        target.style.top = +lastTop + pos.top + "px";
        target.style.left = +lastLeft + pos.left + "px";
      }
    }
  };

  const rotate = (ev, deg) => {
    console.log(TOUCH_STATUS.ROTATE);
    const target = ev.target.parentNode.querySelector("img");
    let lastDeg = target.dataset["angle"] || 0;
    if (!deg) {
      const matrixStr = getComputedStyle(target).getPropertyValue("transform"),
        matrixParams = matrixStr
          .replace("matrix(", "")
          .replace(")")
          .split(",");
      target.dataset["angle"] = getMatrix.apply(null, matrixParams);
    } else {
      target.style.transform = "rotate(" + (+lastDeg + +deg) + "deg)";
    }
  };

  const handleTouchMove = ev => {
    ev.stopPropagation();
    ev.preventDefault();
    const touche = ev.touches[0];
    _lastLocation = { x: touche.clientX, y: touche.clientY };

    if (ROTATE_SWITCH === true) {
      touchStatus = TOUCH_STATUS.ROTATE;
      // 旋转
      let _lastAngle =
        _angle -
        Math.atan2(_lastLocation.y - _center.y, _lastLocation.x - _center.x) /
          (Math.PI / 180);
      rotate(ev, -_lastAngle);
    } else {
      // 移动
      moving(ev, {
        top: _lastLocation.y - _location.y,
        left: _lastLocation.x - _location.x
      });
    }
  };

  return (
    <div
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
    >
      {props.children}
    </div>
  );
};
```

- 文件上传（图片`image/*` 视频`video/*`）,可以自动调用相机
- Promise `无限 .then`，封装接口时，由于异常的传递性，应该调用函数的位置捕获异常

```js
const f1 = () => {
  return Promise.resolve(1);
};

f1()
  .then(res => {
    console.log(res); // 1
  })
  .then(res => {
    console.log(res); // undefined
  })
  .then(res => {
    throw new Error("测试Promise");
  })
  .catch(err => {
    // 改异常捕捉，需要写，否则浏览器会报错
    console.log(err.message); // 测试Promise
  });
```

- `video` iOS 下播放问题，使用 `source` 解决
- 全面屏适背景图适配问题，背景图底边不要出现图案，用图片或纯色填充
- 页面间传递参数，由于后台不支持 `/router/:p1/:p2`，推荐`方式三`

```bash
# 方式一
/router/:p1/:p2
# 取值
const data = this.props.match.params;

# 方式二
/router?p1=v1&p2=v2
# or
const path = {
  pathname : '/router',
  query : {
    p1: v1,
    p2: v2
  }
}
# 取值
const data = this.props.location.query;

# 方式三
const path = {
  pathname : '/router',
  state : {
    p1: v1,
    p2: v2
  }
}
# 取值
const data = this.props.location.state;
```

- 单页面应用部署问题

  - 前后台一块部署

  ```bash
  # JAVA拦截器拦截特定字符做统一跳转
  ```

  - 前后台分开部署

  ```bash
  # Nginx修改反回状态码
  # 接口 location
  location /admin {
    proxy_pass http://pay1.winshareyun.cn;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    rewrite ^/admin(/.*)$ $1 break;
  }
  # 前端代码 location
  location /winsharepayment {
    root /data;
    error_page 404 =200 /winsharepayment/index.html;
  }
  ```

- `<input type='file' multiple />` 多选功能，Android 不支持（QQ 浏览器支持）
- 多行文本 CSS 自动截取功能异常

```bash
属性 -webkit-box-orient 会被插件 autoprefixer 自动去除
需要配置
autoprefixer({
  ...
  remove: false
}),
禁用自动删除功能
```

- 导出模块时，尽量使用 `export {v1, v2}`，这样做代码拆分的时候，可以适当减少代码体积
- `iOS` 端 `contentEditable` 的元素单机无法获取焦点的问题

```bash
# 监听单击事件，获取焦点
<div
  contentEditable={true}
  onClick={e => e.target.focus()}
  ...
/>
```

- `TextareaItem` iOS 端数字统计包含回车时，计数异常，版本 `Ant Design Mobile of React 2.2.2`
- 微信公众号下载调研

  - APP 上传到应用宝，可以下载
  - 不上传应用宝的 APP 或者其他职业，引导用户用浏览器打开进行下载

- 微信公众号跳转 APP 调研（Android，iOS 表现不一致，不同系统版本表现亦不一致）

  - 微信屏蔽 schema 协议，需要合作伙伴才能打开
  - iOS 端 universal links 可以直接打开 APP，类似没有屏蔽的 schema
  - 引导用户用浏览器打开
  - 判断是否安装
    - 安装了，打开 APP
    - 没安装，下载 APP

- list 列表数据刷新问题
  - 普通对象可以使用 `Object.assing()` 复制对象
  - 复杂对象可以使用 `Immutable` 复制
